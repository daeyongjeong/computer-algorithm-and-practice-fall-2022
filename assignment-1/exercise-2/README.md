# Exercise 2

다음 프로그램을 수행할 때 주어진 N에 대해서 N보다 작은 소수(Prime)들을 출력하시오. 또한 N=10000 일 때 N보다 작은 최대 소수를 출력하고, 이때 실행된 곱셈 연산 횟수를 출력하시오.

``` C++
const int N = 500;

main()
{
    int i, j, a[N + 1];
    for (a[1] = 0, i = 2; i <= N; i++)
        a[i] = 1;
    for (i = 2; i <= N / 2; i++)
        for (j = 2; j <= N / i; j++)
            a[i * j] = 0;
    for (i = 1; i <= N; i++)
        if (a[i])
            cout << i << ' ';
    cout << '\\n';
}
```

## 주어진 프로그램 분석

주어진 프로그램은 에라토스테네스의 체 알고리즘을 사용해 N 이하의 소수를 출력하는 프로그램이다.

a라는 이름의 배열은 인덱스 i의 수가 소수인지 아닌지를 의미한다. 배열 인덱스와 수가 일치하도록 하기 위해서 배열의 크기는 N+1만큼 할당했다. 이때 인덱스 0은 사용하지 않는다.

첫 for 문에서는 모든 수를 우선 소수로 보고 1의 값을 할당한다. 이후에는 에라토스테네스의 체 알고리즘에 따라서 소수를 구한다. 2부터 시작해서 각 수의 배수를 배열에서 찾아 소수가 아니라는 의미의 0을 할당한다.

마지막으로 배열의 값이 1인 경우, 즉 소수를 출력한다.

## 오류 수정

* error: C++ requires a type specifier for all declarations: 함수 main()에 형식 지정자가 없기 때문에 오류가 나타난다. int main()의 형태로 고쳐서 해결한다.
* error: use of undeclared identifier 'cout': 식별자 cout이 정의되어 있지 않다는 오류를 해결하기 위해 헤더 파일 iostream을 포함해야 한다.
* error: use of undeclared identifier 'cout'; did you mean 'std::cout'?: iostream 내의 함수들은 namespace std 안에 정의되어 있기 때문에, std::cout 형태로 사용해야 한다. 또는 using 구문을 사용해 namespace std 또는 std::cout을 사용하겠다는 것을 명시해 컴파일러에게 식별자 cout이 정의된 위치를 찾을 수 있게 해야한다. 여기서는 std::cout 형태로 사용해 해결한다.

## 프로그램 실행 결과 1

``` bash
2 3 5 7 11 13 17 19 23 29 31 37 41 43 47 53 59 61 67 71 73 79 83 89 97 101 103 107 109 113 127 131 137 139 149 151 157 163 167 173 179 181 191 193 197 199 211 223 227 229 233 239 241 251 257 263 269 271 277 281 283 293 307 311 313 317 331 337 347 349 353 359 367 373 379 383 389 397 401 409 419 421 431 433 439 443 449 457 461 463 467 479 487 491 499
```

## 문제 해결

1. 주어진 문제에 맞게 N을 10000으로 변경한다.
2. 변수 max_prime를 추가해 소수를 출력하는 과정에서 최대 소수를 추적하도록 한다.
3. 변수 count_mul를 추가해 곱셈 연산이 실행 횟수를 추적하도록 한다.

## 소스 코드

``` C++
#include <iostream>

const int N = 10000;

int main()
{
    int i, j, a[N + 1];
    int max = 0, count = 0;

    for (a[1] = 0, i = 2; i <= N; i++)
        a[i] = 1;

    for (i = 2; i <= N / 2; i++)
    {
        for (j = 2; j <= N / i; j++)
        {
            a[i * j] = 0;
            count++;
        }
    }

    for (i = 1; i <= N; i++)
        if (a[i])
        {
            std::cout << i << ' ';
            max = i;
        }
    std::cout << '\\n';

    std::cout << "Max prime number: " << max << '\\n';
    std::cout << "Number of multiplication: " << count << '\\n';
}
```

## 프로그램 실행 결과 2

``` bash
2 3 5 7 11 13 17 19 23 29 31 37 41 43 47 53 59 61 67 71 73 79 83 89 97 101 103 107 109 113 127 131 137 139 149 151 157 163 167 173 179 181 191 193 197 199 211 223 227 229 233 239 241 251 257 263 269 271 277 281 283 293 307 311 { 중략 } 9697 9719 9721 9733 9739 9743 9749 9767 9769 9781 9787 9791 9803 9811 9817 9829 9833 9839 9851 9857 9859 9871 9883 9887 9901 9907 9923 9929 9931 9941 9949 9967 9973
Max prime number: 9973
Number of multiplication: 73669
```

## 시간, 공간 복잡도 분석

시간 복잡도를 정확하게 구하지는 못하였다. 이를 대략적으로 계산해보면

이고 이를 그림으로 나타내면 O(log n)과 같은 모양이 된다.

정확한 값을 찾아본 결과 O(n log log n)이라고 한다.
공간 복잡도는 원소의 개수만큼 차지하는 배열때문에 O(n)이다.

## 코드 개선

1. 식별자가 나타내고자 하는 개념에 더 가깝도록 이름을 변경한다. 예를 들면 배열 a는 해당 인덱스의 소수 여부를 담고 있으므로 prime_list로 변경한다.
2. 인덱스의 소수 여부를 담기 위해 prime_list의 형식을 int에서 bool로 변경한다. 즉 인덱스가 소수인 경우 true, 아닌 경우 false로 나타내어 표현하고자 하는 개념을 더 잘 표현하도록 한다.
3. 기존 방법에는 더 작은 수에 의해 소수가 아니라고 걸러진 수에 대해서, 배열에 접근해 배수를 0으로 대입하는 비효율이 존재한다. 그 수가 소수가 아니라면, 그 수의 배수 역시 소수가 아니게 된다. 따라서 검사하는 과정을 줄여 코드를 개선한다.
4. 어떤 시점에 i에 대해서, i*k (k < i) 까지는 이미 검사가 완료된다. 따라서 이전에는 N/2 까지의 수에 대해서 소수임을 검사했지만, sqrt(N)까지만 검사해도 충분하다.
5. 위와 동일한 이유로 기존 i*2가 아닌 i*i부터 검사하도록, 즉 j를 2가 아닌 i부터 시작하도록 개선한다.

## 개선한 프로그램 실행 결과

기존과 동일하게 소수를 찾아내면서 곱셈 연산의 실행 횟수가 많이 적어진 것을 확인할 수 있다.

``` bash
2 3 5 7 11 13 17 19 23 29 31 37 41 43 47 53 59 61 67 71 73 79 83 89 97 101 103 107 109 113 127 131 137 139 149 151 157 163 167 173 179 181 191 193 197 199 211 223 227 229 233 239 241 251 257 263 269 271 277 281 283 293 307 311 { 중략 } 9697 9719 9721 9733 9739 9743 9749 9767 9769 9781 9787 9791 9803 9811 9817 9829 9833 9839 9851 9857 9859 9871 9883 9887 9901 9907 9923 9929 9931 9941 9949 9967 9973
Max prime number: 9973
Number of multiplication: 16981
```
